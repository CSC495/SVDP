<html xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:jr="http://jasperreports.sourceforge.net/jasperreports">
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>JasperReports 4.6.0 - Groovy Sample</title>
<style type="text/css">
.title {
	font-family: Arial, Verdana, Helvetica, sans-serif;
	font-size: 28px;
	font-weight: normal;
}

.toc {
	font-family: Courier New, Courier, serif;
	font-size: 12px;
	font-weight: normal;
}

.name {
	font-family: Courier New, Courier, serif;
	font-size: 16px;
	font-weight: bold;
}

.label {
	font-family: Arial, Verdana, Helvetica, sans-serif;
	font-size: 12px;
	font-weight: bold;
	font-style: italic;
}

.description {
	font-family: Arial, Verdana, Helvetica, sans-serif;
	font-size: 12px;
	font-weight: normal;
}

.value {
	font-family: Courier New, Courier, serif;
	font-size: 12px;
	font-weight: normal;
}

.element {
	font-family: Courier New, Courier, serif;
	font-size: 12px;
	font-weight: normal;
}

.attribute {
	font-family: Courier New, Courier, serif;
	font-size: 12px;
	font-weight: bold;
}

.code {
	font-family: Courier New, Courier, serif;
	font-size: 12px;
	font-weight: normal;
}

.copy {
	font-decoration: none;
	font-family: Verdana, Arial, Helvetica, sans-serif;
	font-size: 8pt;
	font-style: normal;
	color: #000000;
}

.subtitle {
	font-family: inherit;
	font-size: inherit;
	font-style: inherit;
	font-weight: bold;
	text-decoration: none;
	color: inherit;
}

</style>
</head>
<body bgcolor="#FFFFFF">
<a name="top"></a>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td colspan="2" align="right"><span class="element"><a href="../../JasperReports-Ultimate-Guide-3.pdf">JasperReports Ultimate Guide</a> - <a href="../../sample.reference.html">Sample Reference</a> - <a href="../../schema.reference.html">Schema Reference</a> - <a href="../../config.reference.html">Configuration Reference</a> - <a href="http://jasperreports.sourceforge.net/api/index.html">API (Javadoc)</a></span>
<br>
</td>
</tr>
<tr>
<td colspan="2">
<hr size="1">
</td>
</tr>
<tr valign="middle">
<td nowrap="true"><span class="title">JasperReports - Groovy Sample (version 4.6.0)</span></td><td align="right"><img src="../../resources/jasperreports.png" border="0"></td>
</tr>
<tr>
<td colspan="2">
<hr size="1">
</td>
</tr>
</table>
<br>
<span class="description"><span class="description">Shows how the Groovy scripting languages could be used inside report templates.</span></span>
<br>
<br>
<span class="element"><a href="http://sourceforge.net/projects/jasperreports/files/jasperreports/JasperReports%204.6.0/jasperreports-4.6.0-project.zip/download" target="_blank">Download All Sample Source Files</a></span>
<br>
<span class="element"><a href="http://jasperforge.org/scm/viewvc.php/tags/jr-4-6-0/jasperreports/demo/samples/groovy/?root=jasperreports" target="_blank">Browse Sample Source Files on SVN</a></span>
<table width="100%" border="0" cellpadding="0" cellspacing="0">
<tr>
<td style="width: 20px;">
<br>
</td><td>
<br>
</td>
</tr>
<tr>
<td colspan="2"><span class="label">Main Features in This Sample</span></td>
</tr>
<tr>
<td>
<br>
</td><td><span class="element"><a href="#reportcompilers">Report Compilers</a></span></td>
</tr>
<tr>
<td>
<br>
</td><td><span class="element"><a href="#groovy">Using the Groovy Scripting Language for Report Expressions (Groovy Report Compiler)</a></span></td>
</tr>
</table>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td><img src="../../resources/px.gif" border="0" width="20" height="1"></td><td><img src="../../resources/px.gif" border="0" width="20" height="1"></td><td><img src="../../resources/px.gif" border="0" width="20" height="1"></td><td><img src="../../resources/px.gif" border="0" width="20" height="1"></td><td width="80%">
<br>
</td><td width="20%">
<br>
</td>
</tr>
<tr>
<td colspan="6" align="right"><a name="reportcompilers"></a><a href="#top" class="toc">top</a></td>
</tr>
<tr>
<td colspan="6">
<hr size="1">
</td>
</tr>
<tr valign="top">
<td><img src="../../resources/jr-16x16.png" border="0"></td><td colspan="4"><span class="name">Report Compilers</span></td><td align="right"><span class="copy">Documented by 
	<a href="mailto:shertage@users.sourceforge.net" class="copy">Sanda Zaharia</a></span></td>
</tr>
<tr>
<td colspan="6">
<br>
</td>
</tr>
<tr valign="top">
<td>
<br>
</td><td nowrap="true"><span class="label">Description / Goal</span></td><td>
<br>
</td><td colspan="3"><span class="description">
How to implement a custom report compiler and how to register it with a custom defined report expression language.
    </span></td>
</tr>
<tr valign="top">
<td>
<br>
</td><td colspan="1"><span class="label">Since</span></td><td>
<br>
</td><td colspan="3"><span class="description">0.6.6</span></td>
</tr>
<tr valign="top">
<td>
<br>
</td><td nowrap="true"><span class="label">Other Samples</span></td><td>
<br>
</td><td colspan="3">
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td><span class="element"><a href="../antcompile/index.html">/demo/samples/antcompile</a></span></td>
</tr>
<tr>
<td><span class="element"><a href="../beanshell/index.html">/demo/samples/beanshell</a></span></td>
</tr>
<tr>
<td><span class="element"><a href="../java1.5/index.html">/demo/samples/java1.5</a></span></td>
</tr>
<tr>
<td><span class="element"><a href="../javascript/index.html">/demo/samples/javascript</a></span></td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="6">
<br>
</td>
</tr>
<tr>
<td>
<br>
</td><td colspan="5"><span class="description">
<b>Compiling Report Templates</b>

<br>

<br>
Source report templates stored into <span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/design/JasperDesign.html" target="_blank">JasperDesign</a></span> objects 
are produced when parsing JRXML files using the 
<span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/xml/JRXmlLoader.html" target="_blank">JRXmlLoader</a></span> class, or created directly by the parent 
application if dynamic report templates are required. The GUI tools for editing 
JasperReports templates also work with this class to make in-memory modifications to 
the report templates before storing them on disk. 
<br>

<span class="code"><code>JasperDesign</code></span> objects contain all static information needed for a report template design. In order to 
make various consistency validations and to incorporate into these 
report templates data used to evaluate all report expressions at runtime, <span class="code"><code>JasperDesign</code></span> objects should became 
subject to the report compilation process before they are filled with data. 
<br>
The compilation process transforms <span class="code"><code>JasperDesign</code></span> objects into 
<span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/JasperReport.html" target="_blank">JasperReport</a></span> objects. Both classes are 
implementations of the same basic <span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/JRReport.html" target="_blank">JRReport</a></span> 
interface. However, <span class="code"><code>JasperReport</code></span> objects cannot be modified once they are produced, 
while <span class="code"><code>JasperDesign</code></span> objects can. This is because some modifications made on the 
report template would probably require re-validation, or if a report expression is 
modified, the compiler-associated data stored inside the report template would have to be 
updated. 
<br>
The report compilation process relies on the <span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/design/JRCompiler.html" target="_blank">JRCompiler</a></span> 
interface, which defines four methods: 
<br>

<br>

<span class="code"><code>public JasperReport compileReport(JasperDesign design) throws JRException;</code></span>

<br>

<span class="code"><code>public JREvaluator loadEvaluator(JasperReport jasperReport) throws JRException;</code></span>

<br>

<span class="code"><code>public JREvaluator loadEvaluator(JasperReport jasperReport, JRDataset dataset) throws JRException;</code></span>

<br>

<span class="code"><code>public JREvaluator loadEvaluator(JasperReport jasperReport, JRCrosstab crosstab) throws JRException;</code></span>

<br>

<br>
The first method is responsible for the report compilation, while the other three generate expression evaluators depending on various input parameters.
<br>
There are several implementations for this compiler interface depending on the language 
used for the report expressions or the mechanism used for their runtime evaluation. 
<br>

<br>

<b><a name="javaCompilers">Report</a> Java Compilers</b>

<br>

<br>
The default language used for the report expressions is Java, but report expressions 
can be written in any other scripting language (like Groovy, JavaScript, BeanShell, etc) as long as a report 
compiler implementation that can evaluate them at runtime is available. The expression language is 
specified using the <span class="code"><code>language</code></span> attribute within the <span class="code"><code>&lt;jasperReport/&gt;</code></span> element.
<br>
Since the most common scenario is to use the Java language for writing report 
expressions, default implementations of the report compiler interface are shipped with 
the library and are ready to use. They generate a Java class from the report expressions 
and store bytecode in the generated <span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/JasperReport.html" target="_blank">JasperReport</a></span> 
object for use at report-filling time.
<br>
There are several available Java report compilers, depending on the JVM compiler used 
to compile the class that is generated on the fly:
<ul>

<li>
<span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/design/JRJdtCompiler.html" target="_blank">JRJdtCompiler</a></span>
</li>

<li>
<span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/design/JRJdk13Compiler.html" target="_blank">JRJdk13Compiler</a></span>
</li>

<li>
<span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/design/JRJdk12Compiler.html" target="_blank">JRJdk12Compiler</a></span>
</li>

<li>
<span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/design/JRJavacCompiler.html" target="_blank">JRJavacCompiler</a></span>
</li>

<li>
<span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/design/JRJikesCompiler.html" target="_blank">JRJikesCompiler</a></span>
</li>

</ul>
The report-compilation process is based on the <span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/JasperCompileManager.html" target="_blank">JasperCompileManager</a></span> facade class. 
This class has various public static methods for compiling report templates that come 
from files, input streams, or in-memory objects. 
<br>
The report compilation facade relies on the report template's <span class="code"><code>language</code></span> attribute to determine 
an appropriate report compiler. If the language is either not set or Java, the facade class 
reads first a configuration property called 
<span class="code"><code>net.sf.jasperreports.compiler.java</code></span> which usually stores the name of the compiler 
implementation class for the Java expression language. If this property is found, the facade 
instantiates a compiler object of that class and delegates the report compilation to it. 
<br>
Similar properties that map the Groovy, JavaScript and 
BeanShell report compilers to the <span class="code"><code>groovy</code></span>, <span class="code"><code>javascript</code></span> and <span class="code"><code>bsh</code></span> report languages  
are also available in JasperReports (see the next section).
<br> 
If the report uses Java as language and no specific compiler has been set for this 
language, the report compilation facade uses the <span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/design/JRDefaultCompiler.html" target="_blank">JRDefaultCompiler</a></span>, 
which triggers a built-in fall back mechanism that 
picks the best Java-based report compiler available in the environment in which the 
report compilation process takes place.
<br> 
The <span class="code"><code>JRDefaultCompiler</code></span> first reads the 
configuration property called <span class="code"><code>net.sf.jasperreports.compiler.class</code></span> to allow 
users to override its built-in compiler-detection logic by providing the name of the report 
compiler implementation to use directly. If no overrides are found, then it first tries to see 
if the JDT compiler from the Eclipse Foundation is available 
in the application&rsquo;s classpath. If it is, the 
<span class="code"><code>JRJdtCompiler</code></span> implementation is used. 
<br>
The current JasperReports distribution ships the JDT compiler packed in the /lib/jdtcompiler. 
jar file.
<br> 
If the JDT compiler is not available, the compilation facade then tries to locate the JDK 
1.3&ndash;compatible Java compiler from Sun Microsystems. This is normally found in the 
tools.jar file that comes with the JDK installation. 
<br>
If the JDK 1.3&ndash;compatible Java compiler is not in the classpath, the fall back search 
mechanism looks for the JDK 1.2&ndash;compatible Java compiler, also from Sun 
Microsystems, in case the application is running in an environment that has a JDK 
version prior to 1.3 installed. This is also found in the tools.jar file from the JDK 
installation. 
<br>
If all these fail, the last thing the fall back mechanism does is to try to launch the 
javac.exe program from the command line in order to compile the temporarily 
generated Java source file on the fly. 
<br>

<br>

<b>Other Expression Scripting Languages</b>

<br>

<br>
As shown above, report expressions can be written in scripting languages other than Java, taking advantage of these specific languages features. 
The only condition is to make available a report compiler implementation able to evaluate them at runtime. 
<br>
The JasperReports library provides built-in compiler implementations for three scripting languages: Groovy, 
JavaScript and BeanShell:
<ul>

<li>
<span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/compilers/JRGroovyCompiler.html" target="_blank">JRGroovyCompiler</a></span>
</li>

<li>
<span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/compilers/JavaScriptCompiler.html" target="_blank">JavaScriptCompiler</a></span>
</li>

<li>
<span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/compilers/JRBshCompiler.html" target="_blank">JRBshCompiler</a></span>
</li>

</ul>
If the <span class="code"><code>language</code></span> attribute is set to <span class="code"><code>groovy</code></span>, or <span class="code"><code>javascript</code></span>, 
or <span class="code"><code>bsh</code></span> (which stands for BeanSHell), or any other scripting language, then the <span class="code"><code>JasperCompileManager</code></span> facade looks for 
the <span class="code"><code>net.sf.jasperreports.compiler.&lt;language&gt;</code></span> property, to see whether a compiler 
implementation class is available for the specified language. Default values for these language-specific properties are:
<ul>

<li>
<span class="code"><code>net.sf.jasperreports.compiler.groovy=net.sf.jasperreports.compilers.JRGroovyCompiler</code></span>
</li>

<li>
<span class="code"><code>net.sf.jasperreports.compiler.bsh=net.sf.jasperreports.compilers.JRBshCompiler</code></span>
</li>

<li>
<span class="code"><code>net.sf.jasperreports.compiler.javascript=net.sf.jasperreports.compilers.JavaScriptCompiler</code></span>
</li>

</ul>

<b><a name="groovyCompiler">The</a> Built-in Groovy Compiler</b>

<br>

<br>
When the <span class="code"><code>language</code></span> attribute is set to <span class="code"><code>groovy</code></span>, 
it means that Groovy scripting language will be used within report expressions. After loading the 
report template into a <span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/design/JasperDesign.html" target="_blank">JasperDesign</a></span> object, the report 
expressions should be read and evaluated properly, and the evaluation data should be then communicated to the resulting 
<span class="code"><code>JasperReport</code></span> object. These operations are performed by the compiler implementation.
<br>
The <span class="code"><code>net.sf.jasperreports.compiler.groovy</code></span> property indicates the Groovy compiler class. The default implementation is:
<br>

<br>

<span class="code"><code>net.sf.jasperreports.compiler.groovy=net.sf.jasperreports.compilers.JRGroovyCompiler</code></span>

<br>

<br>
Let's take a look inside the <span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/compilers/JRGroovyCompiler.html" target="_blank">JRGroovyCompiler</a></span>. It  
extends the <span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/design/JRAbstractJavaCompiler.html" target="_blank">JRAbstractJavaCompiler</a></span> abstract class, 
which extends itself the less specific <span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/design/JRAbstractJavaCompiler.html" target="_blank">JRAbstractCompiler</a></span> abstract class. 
While its parents handle general or Java-related compiling features, the <span class="code"><code>JRGroovyCompiler</code></span> takes care only for the Groovy-specific operations.
It implements four methods from the <span class="code"><code>JRAbstractCompiler</code></span> class:
<br>

<br>

<span class="code"><code>protected abstract String compileUnits(JRCompilationUnit[] units, String classpath, File tempDirFile) throws JRException;</code></span> 

<br>

<span class="code"><code>protected abstract void checkLanguage(String language) throws JRException;</code></span> 

<br>

<span class="code"><code>protected abstract JRCompilationSourceCode generateSourceCode(JRSourceCompileTask sourceTask) throws JRException;</code></span> 

<br>

<span class="code"><code>protected abstract String getSourceFileName(String unitName);</code></span> 

<br>

<br>

<b><a name="bshCompiler">The</a> Built-in BeanShell Compiler</b>

<br>

<br>
When the <span class="code"><code>language</code></span> attribute is set to <span class="code"><code>bsh</code></span>, 
it means that BeanShell scripting language will be used within report expressions. 
The default compiler implementation to handle all BeanShell requirements is specified 
using the <span class="code"><code>net.sf.jasperreports.compiler.bsh</code></span> property:
<br>

<br>

<span class="code"><code>net.sf.jasperreports.compiler.bsh=net.sf.jasperreports.compilers.JRBshCompiler</code></span>

<br>

<br>
The <span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/compilers/JRBshCompiler.html" target="_blank">JRBshCompiler</a></span> class 
extends the <span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/design/JRAbstractJavaCompiler.html" target="_blank">JRAbstractCompiler</a></span> abstract class and 
implements five methods from its parent:
<br>

<br>

<span class="code"><code>protected JREvaluator loadEvaluator(Serializable compileData, String unitName) throws JRException;</code></span> 

<br>

<span class="code"><code>protected abstract String compileUnits(JRCompilationUnit[] units, String classpath, File tempDirFile) throws JRException;</code></span> 

<br>

<span class="code"><code>protected abstract void checkLanguage(String language) throws JRException;</code></span> 

<br>

<span class="code"><code>protected abstract JRCompilationSourceCode generateSourceCode(JRSourceCompileTask sourceTask) throws JRException;</code></span> 

<br>

<span class="code"><code>protected abstract String getSourceFileName(String unitName);</code></span> 

<br>

<br>

<b><a name="jsCompiler">The</a> Built-in JavaScript Compiler</b>

<br>

<br>
When the <span class="code"><code>language</code></span> attribute is set to <span class="code"><code>javascript</code></span>, 
report expressions will be written using JavaScript. 
The default compiler implementation to handle all JavaScript specific stuff is specified 
below:
<br>

<br>

<span class="code"><code>net.sf.jasperreports.compiler.javascript=net.sf.jasperreports.compilers.JavaScriptCompiler</code></span>

<br>

<br>
The <span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/compilers/JavaScriptCompiler.html" target="_blank">JavaScriptCompiler</a></span> class 
extends the <span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/design/JRAbstractJavaCompiler.html" target="_blank">JRAbstractCompiler</a></span> abstract class and 
implements five methods from this:
<br>

<br>

<span class="code"><code>protected JREvaluator loadEvaluator(Serializable compileData, String unitName) throws JRException;</code></span> 

<br>

<span class="code"><code>protected abstract String compileUnits(JRCompilationUnit[] units, String classpath, File tempDirFile) throws JRException;</code></span> 

<br>

<span class="code"><code>protected abstract void checkLanguage(String language) throws JRException;</code></span> 

<br>

<span class="code"><code>protected abstract JRCompilationSourceCode generateSourceCode(JRSourceCompileTask sourceTask) throws JRException;</code></span> 

<br>

<span class="code"><code>protected abstract String getSourceFileName(String unitName);</code></span> 

<br>

<br>

<b>Configuration Properties to Customize Report Compilation</b>

<ul>

<li>
<span class="code"><code>net.sf.jasperreports.compiler.&lt;language&gt;</code></span> - this property was already presented above.</li>

<li>
<span class="code"><code>net.sf.jasperreports.compiler.xml.validation</code></span> - specifies whether the XML validation should be turned 
on or off. By default, it is considered turned on.</li>

<li>
<span class="code"><code>net.sf.jasperreports.compiler.classpath</code></span> - supplies the classpath for some specific compilers.</li>

<li>
<span class="code"><code>net.sf.jasperreports.compiler.temp.dir</code></span> - specifies the temporary location for the files 
generated on the fly. By default is considered the current directory.</li>

<li>
<span class="code"><code>net.sf.jasperreports.compiler.keep.java.file</code></span> - specifies whether the generated source files or 
scripts should be kept in the temporary location after the report gets compiled. By 
default, they are not kept.</li>

</ul>

<b>Specific JDT-Compiler Configuration Properties</b>

<br>

<br>
The <span class="code"><code>JRJdtCompiler</code></span> report compiler can use special JasperReports configuration 
properties to configure the underlying JDT Java compiler, all of them starting with the <span class="code"><code>org.eclipse.jdt.core.</code></span> prefix. 
<br>
For example, to instruct the JDT compiler to observe Java 1.5 
code compatibility, the following properties should be set:
<ul>

<li>
<span class="code"><code>org.eclipse.jdt.core.compiler.source=1.5</code></span>
</li>

<li>
<span class="code"><code>org.eclipse.jdt.core.compiler.compliance=1.5</code></span>
</li>

<li>
<span class="code"><code>org.eclipse.jdt.core.compiler.codegen.TargetPlatform=1.5</code></span>
</li>

</ul>

<b>Ant Task for Report Compiling</b>

<br>

<br>
Since report template compilation is more like a design-time job than a runtime one, a 
custom Ant task has been provided with the library to simplify application development. 
This Ant task is implemented by the <span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/ant/JRAntCompileTask.html" target="_blank">JRAntCompileTask</a></span> 
class. Its syntax and behavior are very similar to the built-in &lt;javac&gt; Ant task. 
The report template compilation task can be declared like this, in a project&rsquo;s build.xml 
file: 
<pre>

  &lt;taskdef name="jrc"
    classname="net.sf.jasperreports.ant.JRAntCompileTask"&gt;
    &lt;classpath&gt;
      &lt;fileset dir="./lib"&gt;
        &lt;include name="**/*.jar"/&gt;
      &lt;/fileset&gt;
    &lt;/classpath&gt;
  &lt;/taskdef&gt;

</pre>
In the preceding example, the lib should contain the jasperreports-x.x.x.jar file 
along with its other required libraries.
<br>
This user-defined Ant task can be used to compile multiple JRXML report template 
files in a single operation by specifying the root directory that contains those files or by 
selecting them using file patterns. 
<br>

<br>

<b>Attributes for Report Compilation Task</b>

<br>

<br>
Following is the list of attributes that can be used inside the Ant report compilation task 
to specify the source files, the destination directory, and other configuration properties: 
<ul>

<li>
<span class="code"><code>srcdir</code></span> - location of the JRXML report template files to be compiled. Required unless 
nested &lt;src&gt; elements are present.</li>

<li>
<span class="code"><code>destdir</code></span> - location to store the compiled report template files (the same as the source 
directory by default).</li>

<li>
<span class="code"><code>compiler</code></span> - name of the class that implements the 
net.sf.jasperreports.engine.design.JRCompiler interface to be used for 
compiling the reports (optional).</li>

<li>
<span class="code"><code>xmlvalidation</code></span> - flag to indicate whether the XML validation should be performed on 
the source report template files (true by default).</li>

<li>
<span class="code"><code>tempdir</code></span> - location to store the temporarily generated files (the current working directory 
by default).</li>

<li>
<span class="code"><code>keepjava</code></span> - flag to indicate if the temporary Java files generated on the fly should be kept 
and not deleted automatically (false by default).</li>

</ul>
The report template compilation task supports nested &lt;src&gt; and &lt;classpath&gt; 
elements, just like the Ant &lt;javac&gt; built-in task. 
<br>

<br>
To figure out more on report compiling process, take a look at the <a href="#groovy" target="_blank" class="element">Groovy sample</a> below, and 
to the other related samples enumerated in the <b>Other Samples</b> section.
	</span></td>
</tr>
<tr>
<td colspan="6">
<br>
</td>
</tr>
<tr>
<td colspan="6" align="right"><a name="groovy"></a><a href="#top" class="toc">top</a></td>
</tr>
<tr>
<td colspan="6">
<hr size="1">
</td>
</tr>
<tr valign="top">
<td><img src="../../resources/jr-16x16.png" border="0"></td><td colspan="4"><span class="name">Using the Groovy Scripting Language for Report Expressions (Groovy Report Compiler)</span></td><td align="right"><span class="copy">Documented by 
	<a href="mailto:shertage@users.sourceforge.net" class="copy">Sanda Zaharia</a></span></td>
</tr>
<tr>
<td colspan="6">
<br>
</td>
</tr>
<tr valign="top">
<td>
<br>
</td><td nowrap="true"><span class="label">Description / Goal</span></td><td>
<br>
</td><td colspan="3"><span class="description">
How to use Groovy scripting for report expressions.
    </span></td>
</tr>
<tr valign="top">
<td>
<br>
</td><td colspan="1"><span class="label">Since</span></td><td>
<br>
</td><td colspan="3"><span class="description">1.2.2</span></td>
</tr>
<tr valign="top">
<td>
<br>
</td><td nowrap="true"><span class="label">Other Samples</span></td><td>
<br>
</td><td colspan="3">
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td><span class="element"><a href="../antcompile/index.html">/demo/samples/antcompile</a></span></td>
</tr>
<tr>
<td><span class="element"><a href="../beanshell/index.html">/demo/samples/beanshell</a></span></td>
</tr>
<tr>
<td><span class="element"><a href="../java1.5/index.html">/demo/samples/java1.5</a></span></td>
</tr>
<tr>
<td><span class="element"><a href="../javascript/index.html">/demo/samples/javascript</a></span></td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="6">
<br>
</td>
</tr>
<tr>
<td>
<br>
</td><td colspan="5"><span class="description">
<b>Groovy Scripting Example</b>

<br>

<br>
This sample contains expressions written using both Java and Groovy languages. This is possible due to the 
<span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/compilers/JRGroovyCompiler.html" target="_blank">JRGroovyCompiler</a></span> implementation which 
allows mixing Java and Groovy together. The report 
<span class="code"><code>language</code></span> attribute is declared below: 
<br>

<br>

<span class="code"><code>language="groovy"</code></span>

<br>

<br>
The main purpose is to show how the Groovy compiler implementation works. In the report template are 
presented some scripting differences between Java and Groovy, and one could notice some advantages 
that Groovy scripting comes with.
<br>
Having two numbers, 3 and 5, their sum is calculated first using a Java expression and then using a Groovy one. The two numbers 
are declared as follows:
<br>

<br>

<span class="code"><code>
&nbsp;&nbsp;&lt;parameter name="A" class="java.lang.Double"&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;defaultValueExpression&gt;&lt;![CDATA[3]]&gt;&lt;/defaultValueExpression&gt;
<br>
&nbsp;&nbsp;&lt;/parameter&gt;
<br>
&nbsp;&nbsp;&lt;parameter name="B" class="java.lang.Double"&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;defaultValueExpression&gt;&lt;![CDATA[5]]&gt;&lt;/defaultValueExpression&gt;
<br>
&nbsp;&nbsp;&lt;/parameter&gt;
</code></span>

<br>

<br>
Both A and B values are declared of <span class="code"><code>java.lang.Double</code></span> type. But their values are let as primitive <span class="code"><code>int</code></span> types, because 
Groovy is able to work with dynamic types. All type conversions are performed at runtime, according to the type declarations above. 
The Groovy scripting above uses a very simplified syntax. Equivalent Java expressions would be:
<br> 

<br> 

<span class="code"><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;defaultValueExpression&gt;&lt;![CDATA[Double.valueOf(3.0)]]&gt;&lt;/defaultValueExpression&gt;</code></span>

<br>

<span class="code"><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;defaultValueExpression&gt;&lt;![CDATA[Double.valueOf(5.0)]]&gt;&lt;/defaultValueExpression&gt;</code></span>

<br>

<br>
The next expression in the report template uses Java to calculate their sum:
<br>

<br>

<span class="code"><code>&nbsp;&nbsp;&lt;textFieldExpression class="java.lang.Double"&gt;&lt;![CDATA[new Double($P{A}.doubleValue() + $P{B}.doubleValue())]]&gt;&lt;/textFieldExpression&gt;</code></span>

<br>

<br>
Here, A and B being <span class="code"><code>Double</code></span>, their <span class="code"><code>doubleValue()</code></span> method is called in order to calculate the sum, 
keeping in mind the backward compatibility with JDK 1.4.x or earlier. After that, because the sum should be 
stored itself in a <span class="code"><code>Double</code></span> value, a new Double object is instantiated for this purpose. The Java expression looks 
rather complicate and one has to take care to instantiate objects with their proper types in order to avoid class 
cast exceptions. 
<br>
Things are changing when using Groovy expressions:
<br>

<br>

<span class="code"><code>&nbsp;&nbsp;&lt;textFieldExpression class="java.lang.Double"&gt;&lt;![CDATA[$P{A} + $P{B}]]&gt;&lt;/textFieldExpression&gt;</code></span>

<br>

<br>
Object creation, autoboxing and unboxing are transparent processes here, the user is no more preoccupated to 
carefully handle object types, the only thing to do being to write a simple addition operation between two report 
parameters (however, the specific parameter syntax still has to be respected). The dynamic data binding and simplified writing 
represent major advantages of Groovy scripts.
<br>

<br>

<b>Running the Sample</b>

<br>

<br>
Running the sample requires the <a href="http://ant.apache.org/" target="_blank" class="element">Apache Ant</a> library. Make sure that <span class="code"><code>ant</code></span> is already installed on your system (version 1.5 or later).
<br>
In a command prompt/terminal window set the current folder to <span class="code"><code>demo/samples/groovy</code></span> within the JasperReports source project and run the <span class="code"><code>&gt; ant test view</code></span> command.
<br>
It will generate all supported document types containing the sample report in the <span class="code"><code>demo/samples/groovy/build/reports</code></span> directory. 
<br>
Then the report will open in the JasperReports internal viewer.
    </span></td>
</tr>
<tr>
<td colspan="6">
<br>
</td>
</tr>
</table>
<br>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td>
<hr size="1">
</td>
</tr>
<tr>
<td align="center"><span class="copy">&copy; 2001-<script language="javascript">document.write((new Date()).getFullYear())</script> Jaspersoft Corporation <a href="http://www.jaspersoft.com" target="_blank" class="copy">www.jaspersoft.com</a></span></td>
</tr>
</table>
</body>
</html>
