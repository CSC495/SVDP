<html xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:jr="http://jasperreports.sourceforge.net/jasperreports">
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>JasperReports 4.6.0 - Hibernate Sample</title>
<style type="text/css">
.title {
	font-family: Arial, Verdana, Helvetica, sans-serif;
	font-size: 28px;
	font-weight: normal;
}

.toc {
	font-family: Courier New, Courier, serif;
	font-size: 12px;
	font-weight: normal;
}

.name {
	font-family: Courier New, Courier, serif;
	font-size: 16px;
	font-weight: bold;
}

.label {
	font-family: Arial, Verdana, Helvetica, sans-serif;
	font-size: 12px;
	font-weight: bold;
	font-style: italic;
}

.description {
	font-family: Arial, Verdana, Helvetica, sans-serif;
	font-size: 12px;
	font-weight: normal;
}

.value {
	font-family: Courier New, Courier, serif;
	font-size: 12px;
	font-weight: normal;
}

.element {
	font-family: Courier New, Courier, serif;
	font-size: 12px;
	font-weight: normal;
}

.attribute {
	font-family: Courier New, Courier, serif;
	font-size: 12px;
	font-weight: bold;
}

.code {
	font-family: Courier New, Courier, serif;
	font-size: 12px;
	font-weight: normal;
}

.copy {
	font-decoration: none;
	font-family: Verdana, Arial, Helvetica, sans-serif;
	font-size: 8pt;
	font-style: normal;
	color: #000000;
}

.subtitle {
	font-family: inherit;
	font-size: inherit;
	font-style: inherit;
	font-weight: bold;
	text-decoration: none;
	color: inherit;
}

</style>
</head>
<body bgcolor="#FFFFFF">
<a name="top"></a>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td colspan="2" align="right"><span class="element"><a href="../../JasperReports-Ultimate-Guide-3.pdf">JasperReports Ultimate Guide</a> - <a href="../../sample.reference.html">Sample Reference</a> - <a href="../../schema.reference.html">Schema Reference</a> - <a href="../../config.reference.html">Configuration Reference</a> - <a href="http://jasperreports.sourceforge.net/api/index.html">API (Javadoc)</a></span>
<br>
</td>
</tr>
<tr>
<td colspan="2">
<hr size="1">
</td>
</tr>
<tr valign="middle">
<td nowrap="true"><span class="title">JasperReports - Hibernate Sample (version 4.6.0)</span></td><td align="right"><img src="../../resources/jasperreports.png" border="0"></td>
</tr>
<tr>
<td colspan="2">
<hr size="1">
</td>
</tr>
</table>
<br>
<span class="description"><span class="description">Shows how HQL could be used in reports.</span></span>
<br>
<br>
<span class="element"><a href="http://sourceforge.net/projects/jasperreports/files/jasperreports/JasperReports%204.6.0/jasperreports-4.6.0-project.zip/download" target="_blank">Download All Sample Source Files</a></span>
<br>
<span class="element"><a href="http://jasperforge.org/scm/viewvc.php/tags/jr-4-6-0/jasperreports/demo/samples/hibernate/?root=jasperreports" target="_blank">Browse Sample Source Files on SVN</a></span>
<table width="100%" border="0" cellpadding="0" cellspacing="0">
<tr>
<td style="width: 20px;">
<br>
</td><td>
<br>
</td>
</tr>
<tr>
<td colspan="2"><span class="label">Main Features in This Sample</span></td>
</tr>
<tr>
<td>
<br>
</td><td><span class="element"><a href="#hibernate">Hibernate (HQL) Query Executer</a></span></td>
</tr>
<tr>
<td>
<br>
</td><td><span class="element"><a href="#queryexecuters">Query Executers</a></span></td>
</tr>
</table>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td><img src="../../resources/px.gif" border="0" width="20" height="1"></td><td><img src="../../resources/px.gif" border="0" width="20" height="1"></td><td><img src="../../resources/px.gif" border="0" width="20" height="1"></td><td><img src="../../resources/px.gif" border="0" width="20" height="1"></td><td width="80%">
<br>
</td><td width="20%">
<br>
</td>
</tr>
<tr>
<td colspan="6" align="right"><a name="queryexecuters"></a><a href="#top" class="toc">top</a></td>
</tr>
<tr>
<td colspan="6">
<hr size="1">
</td>
</tr>
<tr valign="top">
<td><img src="../../resources/jr-16x16.png" border="0"></td><td colspan="4"><span class="name">Query Executers</span></td><td align="right"><span class="copy">Documented by 
	<a href="mailto:shertage@users.sourceforge.net" class="copy">Sanda Zaharia</a></span></td>
</tr>
<tr>
<td colspan="6">
<br>
</td>
</tr>
<tr valign="top">
<td>
<br>
</td><td nowrap="true"><span class="label">Description / Goal</span></td><td>
<br>
</td><td colspan="3"><span class="description">
How to implement a custom query executer and how to associate it with a custom report query language.
    </span></td>
</tr>
<tr valign="top">
<td>
<br>
</td><td colspan="1"><span class="label">Since</span></td><td>
<br>
</td><td colspan="3"><span class="description">1.2.0</span></td>
</tr>
<tr valign="top">
<td>
<br>
</td><td nowrap="true"><span class="label">Other Samples</span></td><td>
<br>
</td><td colspan="3">
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td><span class="element"><a href="../csvdatasource/index.html">/demo/samples/csvdatasource</a></span></td>
</tr>
<tr>
<td><span class="element"><a href="../ejbql/index.html">/demo/samples/ejbql</a></span></td>
</tr>
<tr>
<td><span class="element"><a href="../mondrian/index.html">/demo/samples/mondrian</a></span></td>
</tr>
<tr>
<td><span class="element"><a href="../xmldatasource/index.html">/demo/samples/xmldatasource</a></span></td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="6">
<br>
</td>
</tr>
<tr>
<td>
<br>
</td><td colspan="5"><span class="description">
<b>Data Sources and Report Queries</b>

<br>

<br>
Report generation relies on creating report templates, compiling and filling them with data. 
At fill time, the data necessary to populate the compiled report should be provided to the 
engine. Usually the engine expects to receive these data already stored in a 
<span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/JRDataSource.html" target="_blank">JRDataSource</a></span> object as the 
report data source (see the <a href="../datasource/index.html" target="_blank" class="element">Data Source</a> sample for 
a complete reference). 
<br>
There are situations when creating from scratch a filled 
<span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/JRDataSource.html" target="_blank">JRDataSource</a></span> 
object is quite impossible (for instance, data are stored in relational databases with thousands 
of records, or in huge XML files. In this case, automatic generation of filled 
<span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/JRDataSource.html" target="_blank">JRDataSource</a></span> 
objects is required.
<br>
One possibility is to instruct the engine how to retrieve the necessary data and then create a 
related <span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/JRDataSource.html" target="_blank">JRDataSource</a></span>. 
The most common way to get relevant data is to filter them by running a query and picking up 
filtered data from the data container. For more information about report queries, please consult the 
<a href="../query/index.html" target="_blank" class="element">Query</a> sample.
<br>

<br>

<b>Query Executers</b>

<br>

<br>
Query executers are part of the JasperReports API dedicated to collect and organize data into 
<span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/JRDataSource.html" target="_blank">JRDataSource</a></span> objects used by the 
engine at report filling time.
<br>
A query executer should be able to perform three main tasks, exposed by the 
<span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/query/JRQueryExecuter.html" target="_blank">JRQueryExecuter</a></span> interface:
<ul>

<li>To execute queries and organize retrieved data into a 
<span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/JRDataSource.html" target="_blank">JRDataSource</a></span> implementation. 
This happens when the <span class="code"><code>createDatasource()</code></span> is called.</li>

<li>To cancel a running query, if the user decides to interrupt that query. For doing this, 
the <span class="code"><code>cancelQuery()</code></span> method should be called.</li>

<li>To close resources kept open during the data source iteration, if they are no more necessary. 
Resource closing is handled via the <span class="code"><code>close()</code></span> method.</li>

</ul>
Query executer implementations can benefit from using 
<span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/query/JRAbstractQueryExecuter.html" target="_blank">JRAbstractQueryExecuter</a></span> as 
a base. The abstract base provides query parameter processing functionality and other utility methods.
<br>

<br>
There are several query languages, related to the data storage type. One can use <span class="code"><code>SQL</code></span> 
for retrieving data from relational databases, <span class="code"><code>XPath</code></span> or <span class="code"><code>XQuery</code></span> for navigating through XML 
elements in a document, <span class="code"><code>HQL</code></span> when performing queries using hibernate, etc. Depending on the 
query language, at fill time the engine calls a specific query executer class to execute the query, 
retrieve the data and finally create the data source object.
<br>
Anytime a report query is defined one has to specify the query language using the <span class="code"><code>language</code></span> attribute 
in the <span class="code"><code>&lt;queryString/&gt;</code></span> element. If no language is specified, the <span class="code"><code>SQL</code></span> is considered 
by default, for backward compatibility reasons. Below is defined a query written using the <span class="code"><code>HQL</code></span> language:
<pre>
  &lt;queryString language="hql"&gt;
    &lt;![CDATA[from Address address where city not in ($P{CityFilter}) order by $P!{OrderClause}]] &gt;
  &lt;/queryString&gt;</pre>
Query executer implementations are produced in query executer factories. To register a query executer 
factory for a query language, you have to define a global property named 
<span class="code"><code>net.sf.jasperreports.query.executer.factory.&lt;language&gt;</code></span> in the 
<span class="code"><code>/src/default.jasperreports.properties</code></span> file. The same mechanism can be used to override the 
built-in query executers for a query language, for instance to use a custom query executer for SQL queries. 
<br>
A query executer factory should implement the <span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/query/JRQueryExecuterFactory.html" target="_blank">JRQueryExecuterFactory</a></span> 
interface with the following methods:
<ul>

<li>
<span class="code"><code>public Object[] getBuiltinParameters();</code></span> - retrieves the built-in parameters associated with the query type.</li>

<li>
<span class="code"><code>public JRQueryExecuter createQueryExecuter(JRDataset dataset, Map parameters) throws JRException;</code></span> - creates the 
query executer implementation.</li>

<li>
<span class="code"><code>public boolean supportsQueryParameterType(String className);</code></span> - 
decides whether the query executers created by this factory support a query parameter type.</li>

</ul>
Another way to register new query executer factories, without modifying existing application files, is to register them as 
JasperReports extensions. One or more query executer implementations can be packaged in a 
query executer bundle that can be deployed as a single JAR file. The extension point for query executers 
is represented by the <span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/query/QueryExecuterFactoryBundle.html" target="_blank">QueryExecuterFactoryBundle</a></span> 
interface.
    </span></td>
</tr>
<tr>
<td colspan="6">
<br>
</td>
</tr>
<tr>
<td colspan="6" align="right"><a name="hibernate"></a><a href="#top" class="toc">top</a></td>
</tr>
<tr>
<td colspan="6">
<hr size="1">
</td>
</tr>
<tr valign="top">
<td><img src="../../resources/jr-16x16.png" border="0"></td><td colspan="4"><span class="name">Hibernate (HQL) Query Executer</span></td><td align="right"><span class="copy">Documented by 
	<a href="mailto:shertage@users.sourceforge.net" class="copy">Sanda Zaharia</a></span></td>
</tr>
<tr>
<td colspan="6">
<br>
</td>
</tr>
<tr valign="top">
<td>
<br>
</td><td nowrap="true"><span class="label">Description / Goal</span></td><td>
<br>
</td><td colspan="3"><span class="description">
How to fill reports using embedded Hibernate (HQL) queries.
    </span></td>
</tr>
<tr valign="top">
<td>
<br>
</td><td colspan="1"><span class="label">Since</span></td><td>
<br>
</td><td colspan="3"><span class="description">1.2.0</span></td>
</tr>
<tr>
<td colspan="6">
<br>
</td>
</tr>
<tr>
<td>
<br>
</td><td colspan="5"><span class="description">
<b>The Hibernate Query Executer</b>

<br>

<br>
A large variety of multi-tier applications rely on database interrogations. In these applications accessing data represents a 
well-delimited layer with specific processing tools, able to create/close connections to a database, to access/modify/retrieve 
data or metadata, to commit/rollback transactions, etc.
<br>
One of these middle-tier tools dedicated to data access is Hibernate (today: Hibernate 3.3): a collection of correlated projects 
using POJO-style domain models that extend the Object/Relational mapping the initial Hibernate releases relied on.
<br>
In order to perform queries, Hibernate uses HQL (the <b>H</b>ibernate <b>Q</b>uery <b>L</b>anguage), its specific query language 
with a syntax almost similar to SQL (one can find the HQL basics <a href="http://docs.jboss.org/hibernate/core/3.3/reference/en/html/queryhql.html" target="_blank" class="element">here</a>). 
<br>
So, we have a dedicated tool to interrogate a database, and a related query language. Now it's time to register a new query 
executer factory: 
<br>

<br>
&nbsp;&nbsp;<span class="code"><code>net.sf.jasperreports.query.executer.factory.hql=net.sf.jasperreports.engine.query.JRHibernateQueryExecuterFactory</code></span>

<br>

<br>
The <span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/query/JRHibernateQueryExecuterFactory.html" target="_blank">JRHibernateQueryExecuterFactory</a></span> creates 
<span class="element"><a href="http://jasperreports.sourceforge.net/api/net/sf/jasperreports/engine/query/JRHibernateQueryExecuterFactory.html" target="_blank">JRHibernateQueryExecuterFactory</a></span> instances to
handle data access through Hibernate APIs. The factory automatically defines a parameter named <span class="code"><code>HIBERNATE_SESSION</code></span> of type 
<span class="code"><code>org.hibernate.Session</code></span>, used by the query executer to create the query.
<br>
HQL queries can embed two types of parameters:
<ul>

<li>Query parameters: embedded using the <span class="code"><code>$P{..}</code></span> syntax.</li>

<li>Statement substitution parameters: embedded using the <span class="code"><code>$P!{..}</code></span> syntax.</li>

</ul>
The HQL query execution can be configured via the following properties:
<ul>

<li>
<span class="code"><code>net.sf.jasperreports.hql.query.run.type</code></span> - configures how the query result is fetched. It can take the following 
possible values: <span class="code"><code>list</code></span>, <span class="code"><code>scroll</code></span>, <span class="code"><code>iterate</code></span>.</li>

<li>
<span class="code"><code>net.sf.jasperreports.jdbc.fetch.size</code></span> - specifies the fetch size.</li>

<li>
<span class="code"><code>net.sf.jasperreports.hql.clear.cache</code></span> - flag used to clear the Hibernate&rsquo;s first-level cache after each page fetching 
when working with a large amount of data.</li>

<li>
<span class="code"><code>net.sf.jasperreports.hql.query.list.page.size</code></span> - enables paginated result retrieval and specifies the page size.</li>

<li>
<span class="code"><code>net.sf.jasperreports.hql.field.mapping.descriptions</code></span> - instructs the engine to use rather field descriptions than names 
when mapping report fields to values from the Hibernate result.</li>

</ul>

<b>The Hibernate Sample</b>

<br>

<br>
This sample shows how to perform queries and retrieve data from a relational database using Hibernate. 
The output consists in two separate reports: the standalone document <span class="code"><code>AddressesReport</code></span>, and 
the <span class="code"><code>HibernateQueryReport</code></span> which contains a subreport. Two tables in the HSQLDB database are 
involved: <span class="code"><code>ADDRESS</code></span> and <span class="code"><code>DOCUMENT</code></span>.
<br>
The Hibernate configuration information is kept in the <span class="code"><code>src/hibernate.cfg.xml</code></span> folder:
<pre>
&lt;hibernate-configuration&gt;

  &lt;session-factory&gt;
    &lt;property name="connection.driver_class"&gt;org.hsqldb.jdbcDriver&lt;/property&gt;
    &lt;property name="connection.url"&gt;jdbc:hsqldb:hsql://localhost&lt;/property&gt;
    &lt;property name="connection.username"&gt;sa&lt;/property&gt;
    &lt;property name="connection.password"&gt;&lt;/property&gt;
    &lt;property name="dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/property&gt;
    &lt;property name="connection.pool_size"&gt;1&lt;/property&gt;
    &lt;mapping resource="Address.hbm.xml"/&gt;
    &lt;mapping resource="Document.hbm.xml"/&gt;
  &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre>
In order to create a Hibernate session one has to specify the properties and mapping resources in the 
<span class="code"><code>&lt;session-factory&gt;</code></span> element above.
<br>
In our case there are two mapping resources configurated in the XML files below:
<br>

<br>
1.&nbsp;&nbsp;&nbsp;<span class="code"><code>src/Address.hbm.xml</code></span> mapping the Address entity object 
(See the <span class="code"><code>src/Address.java</code></span> file) to the <span class="code"><code>ADDRESS</code></span> table in the database:
<pre>
  &lt;hibernate-mapping&gt;

  &lt;class name="Address" table="ADDRESS"&gt;
    &lt;id name="id" column="ID"&gt;
      &lt;generator class="increment"/&gt;
    &lt;/id&gt;

    &lt;property name="firstName" column="FIRSTNAME"/&gt;
    &lt;property name="lastName" column="LASTNAME"/&gt;
    &lt;property name="street" column="STREET"/&gt;
    &lt;property name="city" column="CITY"/&gt;

    &lt;set name="documents" inverse="true"&gt;
      &lt;key column="ADDRESSID"/&gt;
      &lt;one-to-many class="Document"/&gt;
    &lt;/set&gt;
  &lt;/class&gt;

  &lt;/hibernate-mapping&gt;</pre>
2.&nbsp;&nbsp;&nbsp;<span class="code"><code>src/Document.hbm.xml</code></span> mapping the Document entity object 
(See the <span class="code"><code>src/Document.java</code></span> file) to the <span class="code"><code>DOCUMENT</code></span> table in the database:
<pre>
  &lt;hibernate-mapping&gt;
	
    &lt;class name="Document" table="DOCUMENT"&gt;
      &lt;id name="id" column="ID"&gt;
        &lt;generator class="increment"/&gt;
      &lt;/id&gt;

      &lt;many-to-one name="address" column="ADDRESSID"/&gt;

      &lt;property name="total" column="TOTAL"/&gt;
    &lt;/class&gt;
	
  &lt;/hibernate-mapping&gt;</pre>
One can see above that an <span class="code"><code>Address</code></span> object contains a set of <span class="code"><code>Document</code></span> objects, 
all with the same <span class="code"><code>ADDRESSID</code></span> value. The one-to-many relationship between the <span class="code"><code>ADDRESS</code></span> 
table and <span class="code"><code>DOCUMENT</code></span> is intermediated by the <span class="code"><code>ADDRESS.ADDRESSID</code></span> foreign key column.
<br>

<br>
The <span class="code"><code>AddressReport</code></span> enumerates customers with their addresses and related documents and document totals, 
filtered by their city location (see the <a href="#cityfilter" target="_blank" class="element">CityFilter</a> parameter). The HQL query 
string is the following:
<pre>
  &lt;parameter name="CityFilter" class="java.util.List"/&gt;
  &lt;queryString language="hql"&gt;
    &lt;![CDATA[select address as address, document.id as documentId, document.total as documentTotal
      from Address as address join address.documents as document
      where city not in ($P{CityFilter})
      order by address.city, address.lastName, address.firstName, address.id]] &gt;
  &lt;/queryString&gt;</pre>
In the query above, because of the table join, customers with no related documents in the 
<span class="code"><code>DOCUMENTS</code></span> table are not included.
<br>

<br>
The <span class="code"><code>HibernateQueryReport</code></span> report retrieves all customer addresses from the <span class="code"><code>ADDRESS</code></span> table, 
without taking into account if there are or no customer related documents in the <span class="code"><code>DOCUMENTS</code></span> table. Customers 
are also filtered by the <a href="#cityfilter" target="_blank" class="element">CityFilter</a> parameter. If related documents exist, their 
data are retrieved using the <span class="code"><code>DocumentsReport</code></span> subreport (see the <span class="code"><code>reports/DocumentsReport.jrxml</code></span> file). 
<br>
Here customers with no related documents are included too.
<br>
Customers are also grouped by their city.
<br>

<br>
Now it's time to take a look in the <span class="code"><code>reports/HibernateQueryReport.jrxml</code></span> file at the report HQL query string:
<pre>
  &lt;queryString language="hql"&gt;
    &lt;![CDATA[from Address address where city not in ($P{CityFilter}) order by $P!{OrderClause}]] &gt;
  &lt;/queryString&gt;</pre>
And then, at the <span class="code"><code>Documents</code></span> subreport, for each customer:
<pre>
  &lt;subreport&gt;
    &lt;reportElement x="65" y="21" width="50" height="20" isRemoveLineWhenBlank="true"/&gt;
    &lt;dataSourceExpression&gt;&lt;![CDATA[new JRBeanCollectionDataSource($F{documents})]] &gt;&lt;/dataSourceExpression&gt;
    &lt;subreportExpression class="java.lang.String"&gt;&lt;![CDATA["DocumentsReport.jasper"]] &gt;&lt;/subreportExpression&gt;
  &lt;/subreport&gt;</pre>

The <span class="code"><code><a name="cityfilter">CityFilter</a></code></span> parameter and all other report parameters are created 
in the <span class="code"><code>src/HibernateApp.java</code></span> class file, via the <span class="code"><code> getParameters(Session session)</code></span> method:
<pre>
  private static Map getParameters(Session session)
  {
    Map parameters = new HashMap();
    parameters.put(JRHibernateQueryExecuterFactory.PARAMETER_HIBERNATE_SESSION, session);
    parameters.put("ReportTitle", "Address Report");
    List cityFilter = new ArrayList(3);
    cityFilter.add("Boston");
    cityFilter.add("Chicago");
    cityFilter.add("Oslo");
    parameters.put("CityFilter", cityFilter);
    parameters.put("OrderClause", "city");
    return parameters;
  }</pre>
At fill time, a Hibernate session is created and a transaction gets started. Report parameters are set and then 
the two compiled reports are filled with data. If all goes ok, the transaction is then rolled back and the session 
is closed:
<pre>
  public void fill() throws JRException
  {
    Session session = createSession();
    Transaction transaction = session.beginTransaction();

    Map params = getParameters(session);
	
    File[] files = 
      new File[]{
        new File("build/reports/AddressesReport.jasper"),
        new File("build/reports/HibernateQueryReport.jasper")
        };
    for(int i = 0; i &lt; files.length; i++)
    {
      File reportFile = files[i];
      long start = System.currentTimeMillis();
      JasperFillManager.fillReportToFile(reportFile.getAbsolutePath(), params);
      System.err.println(
        "Report : " + reportFile + ". Filling time : " + (System.currentTimeMillis() - start)
        );
    }
	
    transaction.rollback();
    session.close();
  }
  
  private static Session createSession()
  {
    SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();
	
    return sessionFactory.openSession();
  }</pre>

<b>Running the Sample</b>

<br>

<br>
Running the sample requires the <a href="http://ant.apache.org/" target="_blank" class="element">Apache Ant</a> library. Make sure that <span class="code"><code>ant</code></span> is already installed on your system (version 1.5 or later).
<br>
In a command prompt/terminal window set the current folder to <span class="code"><code>demo/hsqldb</code></span> within the JasperReports source project and run the <span class="code"><code>&gt; ant runServer</code></span> command. 
It will start the HSQLDB server shipped with the JasperReports distribution package. Let this terminal running the HSQLDB server.  
<br>
Open a new command prompt/terminal window and set the current folder to <span class="code"><code>demo/samples/hibernate</code></span> within the JasperReports source project and run the <span class="code"><code>&gt; ant test view</code></span> command.
<br>
It will generate all supported document types containing the sample report in the <span class="code"><code>demo/samples/hibernate/build/reports</code></span> directory. 
<br>
Then the report will open in the JasperReports internal viewer.
    </span></td>
</tr>
<tr>
<td colspan="6">
<br>
</td>
</tr>
</table>
<br>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td>
<hr size="1">
</td>
</tr>
<tr>
<td align="center"><span class="copy">&copy; 2001-<script language="javascript">document.write((new Date()).getFullYear())</script> Jaspersoft Corporation <a href="http://www.jaspersoft.com" target="_blank" class="copy">www.jaspersoft.com</a></span></td>
</tr>
</table>
</body>
</html>
